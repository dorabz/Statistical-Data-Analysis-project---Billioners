---
title: "SAP - projekt - Milijarderi"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'projekt_sap_dokumentacija.pdf'))})
subtitle: "Uspjeh učenika u nastavi"
author: "Dora Bezuk, Marcela Matas, Josip Arelic, Domagoj Marinello"
date: "13.11.2022."
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r error=FALSE, message=FALSE, warning=FALSE, include=FALSE}
library("readxl")
library(tidyverse)
library(dplyr)
library(fastDummies)

```

# Uvod

Pitanja:

1. Ima li neki kontinent statistički značajno više miljarda?

2. Jesu li milijarderi koji su nasljedili bogastvo statistički značajno bogatiji od onih koji nisu?

3. Možete li iz danih varijabli predvidjeti njihovo bogatstvo?

4. Kada biste birali karijeru isključivo prema kriteriju da se obogatite, koju biste industriju izabrali?


# Deskriptivna analiza

Potrebno je učitati podatke.
```{r include=FALSE}
# Učitavanje podataka iz excel datoteke
# Promijeniti path u put do datoteke s podacima
bill_data <- read_excel("billionaires.xlsx")
```

```{r include=FALSE}
dim(bill_data) # dimenzije: 2614 redaka i 22 stupaca
names(bill_data) # imena stupaca
view(bill_data)

# klase pojedinih stupaca
sapply(bill_data, class)

# klasa tablice
class(bill_data) 
# zaključak: bill_data podaci su dobro učitani
```

```{r}
# Pomoćna funkcija za izbacivanje stršećih vrijednosti
remove_outliers <- function(data, data_column) {
  quartiles <- quantile(data_column, probs=c(.25, .75), na.rm = FALSE)
  IQR <- IQR(data_column)
  Lower <- quartiles[1] - 1.5*IQR
  Upper <- quartiles[2] + 1.5*IQR 
  
  return(subset(data, data_column >= Lower & data_column <= Upper))
}

cat('\n Dimenzija podataka: ', dim(bill_data))
```



```{r}
for (col_name in names(bill_data)){
  if (sum(is.na(bill_data[,col_name])) > 0){
    cat('Ukupno nedostajućih vrijednosti za varijablu'
        ,col_name, ': ', sum(is.na(bill_data[,col_name])),'\n')
  }
}

```


```{r}
summary(bill_data)


```
```{r}
sapply(bill_data, class)
```
Naš dataset sastoji se od character i numeric varijabli.

Prvo promotrimo numeričke varijable.
```{r}

hist(bill_data$`wealth.worth in billions` ,main='wealth worth in billions', xlab='wealth', ylab='Frequency', col="pink")

boxplot(bill_data$`wealth.worth in billions`)
summary(bill_data$`wealth.worth in billions`)

```
```{r}

barplot(table(bill_data$wealth.type),las=2,cex.names=.9,main='Wealth type',col="pink")
barplot(table(bill_data$wealth.how.industry),las=2,cex.names=.7,main='Industry',col="pink")
print('Podjela po spolu: ')
table(bill_data$demographics.gender)

```

# Pitanja

## 1. Ima li neki kontinent statistički značajno više miljardi?

```{r}
levels(factor(bill_data$location.region))
```

```{r}
class(bill_data$location.region)

```
Treba li tip stupca biti factor?


Ima li nedostajućih vrijednosti?
```{r}
# is.na ce nam vratiti logical vektor koji ima TRUE na mjestima gdje ima NA:
sum(is.na(bill_data$location.region)) 
 

```

Nema nedostajućih vrijednosti
```{r}
table(bill_data$location.region)



```

```{r}


bill_data$location.citizenship[bill_data$location.region == "Middle East/North Africa"]

```

Sada možemo združiti podatke ovisno o kontinentu.

Kopirajmo najprije podatke u novi data.frame kako ne bi promijenili prave vrijednosti.

```{r}
bill_data_copy = data.frame(bill_data)
tracemem(bill_data)==tracemem(bill_data_copy)
untracemem(bill_data_copy)
untracemem(bill_data_copy)
```



```{r,results='hide'}
# Zdruzimo Europu
for (column_name in c("Europe")){
  bill_data_copy$location.region[bill_data_copy$location.region == column_name] = "Europe";
}

# Zdruzimo Afriku
for (column_name in c("Lebanon","Egypt","Morocco","Algeria")){
  bill_data_copy$location.region[bill_data_copy$location.citizenship == column_name] = "Africa";
}

for (column_name in c("Sub-Saharan Africa")){
  bill_data_copy$location.region[bill_data_copy$location.region == column_name] = "Africa";
}

# zdruzimo Sjevernu Ameriku
for (column_name in c("North America")){
  bill_data_copy$location.region[bill_data_copy$location.region == column_name] = "North America";
}

# Zdruzimo Južnu Ameriku
for (column_name in c("Latin America")){
  bill_data_copy$location.region[bill_data_copy$location.region == column_name] = "South America";
}

# Zdruzimo Aziju
for (column_name in c("East Asia","South Asia")){
  bill_data_copy$location.region[bill_data_copy$location.region == column_name] = "Asia";
}
for (column_name in c("Saudi Arabia","Kuwait","United Arab Emirates","Israel","Turkey","Oman","Bahrain")){
  bill_data_copy$location.region[bill_data_copy$location.citizenship == column_name] = "Asia";
}


bill_data_copy

```
```{r}
tbl = table(bill_data_copy$location.region)
print(tbl)

```


##continent_frequency=transform(bill_data_copy,continent_frequency=ave(seq(nrow(bill_data_copy)),location.region ,FUN=length)
df1=transform(bill_data_copy,continent_frequency=ave(seq(nrow(bill_data_copy)),location.region ,FUN=length))
df1

```{r}
df <- data.frame(continent=c("Europe", "Asia", "Africa","North America","South America"),
                continent_frequency=c(697, 699, 43, 992, 182))
head(df)

library(ggplot2)


# Barplot
p<-ggplot(data=df, aes(x=continent, y=continent_frequency)) +
  geom_bar(stat="identity")
p


box_edu <- ggplot(bill_data_copy %>% filter(!location.region=="0"), aes(x=location.region, y= wealth.worth.in.billions, fill=location.region)) +
    geom_boxplot(alpha=0.7, ) + scale_y_log10() +
    stat_summary(fun=mean, geom="point", shape=20, size=7, color="black", fill="black") +
    theme(legend.position="none") + labs(x="Continent",y="Wealth")+
    scale_fill_brewer(name="Continent",palette="GnBu")
box_edu






```
Pretpostavke ANOVA-e su:

- nezavisnost pojedinih podataka u uzorcima,
- normalna razdioba podataka,
- homogenost varijanci među populacijama. 

Kad su veličine grupa podjednake, ANOVA je relativno robusna metoda na blaga odstupanja od pretpostavke normalnosti i homogenosti varijanci. Ipak, dobro je provjeriti koliko su ta odstupanja velika. 

Provjera normalnosti može se za svaku pojedinu grupu napraviti KS testom ili Lillieforsovom inačicom KS testa. U ovom slučaju razmatrat ćemo location.region kao varijablu koja određuje grupe (populacije) i wealth kao zavisnu varijablu.

```{r test pretpostavki - normalnost}

# TODO: zakomentiraj ovu liniju ako ne želimo logaritmirati cijenu

wealth <- log(bill_data_copy$wealth.worth.in.billions, 2)

require(nortest)
lillie.test(wealth)

lillie.test(wealth[bill_data_copy$location.region=='Africa'])
lillie.test(wealth[bill_data_copy$location.region=='Europe'])
lillie.test(wealth[bill_data_copy$location.region=='South America'])
lillie.test(wealth[bill_data_copy$location.region=='North America'])
lillie.test(wealth[bill_data_copy$location.region=='Asia'])


hist(wealth[bill_data_copy$location.region=='Africa'])
hist(wealth[bill_data_copy$location.region=='Europe'])
hist(wealth[bill_data_copy$location.region=='South America'])
hist(wealth[bill_data_copy$location.region=='North America'])
hist(wealth[bill_data_copy$location.region=='Asia'])

```
```{r test homogenosti}

# Testiranje homogenosti varijance uzoraka Bartlettovim testom

##bartlett.test(bill_data_copy$wealth.worth.in.billions ~ bill_data_copy$location.region)

var((wealth[bill_data_copy$location.region=='Africa']))
var((wealth[bill_data_copy$location.region=='Asia']))
var((wealth[bill_data_copy$location.region=='Europe']))
var((wealth[bill_data_copy$location.region=='North America']))
var((wealth[bill_data_copy$location.region=='South America']))
```

Provjerimo postoje li razlike u prihodima za različite razine školovanja klijenata. 

```{r test razlike u prihodima}

# Graficki prikaz podataka
boxplot(wealth ~ bill_data_copy$location.region)

# Test
a = aov(wealth ~ bill_data_copy$location.region)
summary(a)

```


## 2. Jesu li milijarderi koji su nasljedili bogastvo statistički značajno bogatiji od onih koji nisu?

Potrebno je pripremiti podatke za obradu, razdvojiti podatke iz tablice po polju
how.inherited u dva slučaja: inherited (oni koju su nasljedili bogatstvo) i 
non_inherited (oni koji nisu nasljedili bogatstvo).

```{r}
inherited = bill_data[bill_data$wealth.how.inherited!="not inherited",]
non_inherited = bill_data[bill_data$wealth.how.inherited=="not inherited",]
```

Zatim je potrebno izračunati srednju vrijednost (mean) posebno za svaki slučaj
uzimajući u obzir polje worth.in billions.

```{r}
inherited_mean = mean(inherited$`wealth.worth in billions`)
print(inherited_mean)

non_inherited_mean = mean(non_inherited$`wealth.worth in billions`)
print(non_inherited_mean)

```

Na temelju male razlike u srednjim vrijednostima, ne postoje indikacije da su 
milijarderi koji su nasljedili bogatstvo statistički značajno bogatiji 
od onih koji nisu. No, navedeno je potrebno provjeriti.


Kako bi bolje vizualizirali podatke crtamo histogram i box plot za svaki od
slučaja:

```{r}
hist(inherited$`wealth.worth in billions`, breaks = 20)
boxplot(inherited$`wealth.worth in billions`)

hist(non_inherited$`wealth.worth in billions`, breaks = 20)
boxplot(non_inherited$`wealth.worth in billions`)
```

Iz prikazane vizualizacije uočavamo kako se podaci ne ravnaju po
normalnoj distribuciji.

Što se može bolje vidjeti sa sljedećih prikaza:
```{r}
qqnorm(inherited$`wealth.worth in billions`, pch = 1, frame = FALSE,main='Inherited')
qqline(inherited$`wealth.worth in billions`, col = "blue", lwd = 2)

qqnorm(non_inherited$`wealth.worth in billions`, pch = 1, frame = FALSE,main='Non inherited')
qqline(non_inherited$`wealth.worth in billions`, col = "red", lwd = 2)

```

Ipak, uočeno je potrebno dodatno ispitati koristeći Kolmogorov–Smirnov test 
kojim se utvrđuje ravna li se distribucija po normalnoj razdiobi.

```{r}
ks.test(inherited$`wealth.worth in billions`, y="pnorm")
ks.test(non_inherited$`wealth.worth in billions`, y="pnorm")
```

Iz dobivenih p vrijednosti u oba slučaja odbacujemo mogućnost da se distribucije
ravnaju po normalnoj razdiobi. 

Time je potvrđena pretpostavka da se podaci ne ravnaju po normalnoj distribuciji.

Potrebno je koristiti neparametarski test Mann–Whitney U test, koji se koristi 
kada se podaci se ravnaju po istim distribucijama (obje distribucije su nakošene
u desno) i uzorci su nezavisni iz jedne i druge populacije (jedna osoba ne može
nasljediti i nenasljediti bogatstvo).


Hipoteze glase:
$$ \begin{aligned}
H_0&: \mu_1 = \mu_2 \\
H_1&: \mu_1 > \mu_2 \quad \quad 
\end{aligned} $$


```{r}
 
wilcox.test(inherited_mean, non_inherited_mean, alt = "greater")

```

Zbog p-vrijednost jednake 0.5, na temelju značajnosti od 50% ne možemo odbaciti 
$H_0$ hipotezu o jednakosti prosječnih vrijednosti bogatstva u korist $H_1$, 
odnosno možemo reći da milijarderi koji su nasljedili bogatstvo nisu statistički
značajno bogatiji od onih koji nisu.



## 3. Možete li iz danih varijabli predvidjeti njihovo bogatstvo?

 + je li dobro tu koristiti sve milijardere s popisa 2014 + milijarderi s prethodnih popisa (ako nisu na popisu iz 2014. godine)
 
 
```{r}
# bill_data

# Izbacujemo stupce:
# name
# company.name
# rank
# location.gdp, više od pola vrijednosti su 0 (netočan podatak)
# location.coutnry.code i location.citizenship a koristimo location.region koji je veće granulacije
# wealth.how.from emerging, wealth.how.was founder, wealth.how.was political su konstantne varijable
# company.sector jer ima previše različitih vrijednosti, koje kad bi one hot encodali bi dali previše stupaca

exclude_cols = c("name", "company.name", "rank", "location.gdp", "location.country code", "location.citizenship", "wealth.how.from emerging", "wealth.how.was founder", "wealth.how.was political", "company.sector")

# exclude columns and sort
bill_data_clean <- bill_data %>% select(-one_of(exclude_cols)) %>% arrange(year)

# to lowercase for consistency
bill_data_clean[["company.relationship"]] <- tolower(bill_data_clean[["company.relationship"]] )

# remove invalid data
bill_data_clean <- bill_data_clean %>% filter(demographics.age > 0)
bill_data_clean <- bill_data_clean %>% filter(!location.region == "0")

# inflation rate $1.00 (1996) -> $1.51 (2014), +50.9%
# inflation rate $1.00 (2001) -> $1.34 (2014), +33.7%
bill_data_clean[bill_data_clean$year == "1996", "wealth.worth in billions"] <- bill_data_clean[bill_data_clean$year == "1996", "wealth.worth in billions"] * 1.509
bill_data_clean[bill_data_clean$year == "2001", "wealth.worth in billions"] <- bill_data_clean[bill_data_clean$year == "2001", "wealth.worth in billions"] * 1.337

# Iskoristili smo godinu da ažuriramo cijene (inflacija), sad ju odbacujemo
bill_data_clean <- bill_data_clean %>% select(., -year)

# merge similar roles to avoid 1 column = 1 row data
bill_data_clean$company.relationship <- gsub(".*\b(owner)\b.*", "owner", bill_data_clean$company.relationship)
bill_data_clean$company.relationship <- gsub(".*(ceo|chief executive officeor|chief executive officer|chief executive|exectuitve).*", "ceo", bill_data_clean$company.relationship)
bill_data_clean$company.relationship <- gsub(".*(founder).*", "founder", bill_data_clean$company.relationship)
bill_data_clean$company.relationship <- gsub(".*(chair|chari).*", "chairman", bill_data_clean$company.relationship)
bill_data_clean$company.relationship <- gsub(".*(director).*", "director", bill_data_clean$company.relationship)
bill_data_clean$company.relationship <- gsub(".*(head).*", "head", bill_data_clean$company.relationship)
bill_data_clean$company.relationship <- gsub(".*(president).*", "president", bill_data_clean$company.relationship)

# drop small amount of rows with na values
bill_data_clean <- bill_data_clean %>% drop_na()

# split dataset to numeric and categorical (non-ordinal)
bill_categorical <- bill_data_clean %>% select(where(is_character))
bill_numeric <- bill_data_clean %>% select(where(is.numeric))

# one hot encode categorical data
bill_categorical_onehot = dummy_cols(bill_categorical, remove_first_dummy = TRUE, remove_selected_columns = TRUE)

# filter indicators with 5 or more rows, indicators with less than 5 would cause problems
bill_categorical_onehot <- bill_categorical_onehot[, colSums(bill_categorical_onehot) > 5]

# concat numerical and categorical columns
bill_data_clean <- bind_cols(bill_numeric, bill_categorical_onehot)
```


```{r}
# remove variables which strongly and linearly correlate 
correlation_threshold = 0.9
tmp <- cor(bill_data_clean)
tmp[upper.tri(tmp)] <- 0
diag(tmp) <- 0  # clean diagonal which is always 1
bill_data_clean <- bill_data_clean[, apply(tmp,2,function(x) all(x<= correlation_threshold))]

# remove outliers
# TODO: zakomentiraj ovu liniju ako ne želimo removeati outliere
bill_data_clean <- remove_outliers(bill_data_clean, bill_data_clean$`wealth.worth in billions`)

# extract y column for later use
wealth <- bill_data_clean$`wealth.worth in billions`

# TODO: zakomentiraj ovu liniju ako ne želimo logaritmirati cijenu
# wealth <- log(wealth, 2)
```

```{r}
# x setup, y = wealth
normalized<-function(y) {
  x<-y[!is.na(y)]
  x<-(x - min(x)) / (max(x) - min(x))
  y[!is.na(y)]<-x
  return(y)
}

# `wealth.how.industry_Retail, Restaurant` casues fitting issues
exclude_cols = c("wealth.worth in billions", "wealth.how.industry_Retail, Restaurant")
x <- bill_data_clean %>% select(-one_of(exclude_cols))
x[, c("company.founded", "demographics.age")] <- apply(x[, c("company.founded", "demographics.age")] , 2 , normalized) # minmax scaling
x <- x[,order(colnames(x))]

```

```{r}
model_all_vars <- lm(wealth ~ . , x)
summary(model_all_vars)
```

```{r}
### Pronalazak najboljih prediktora na sljedeći način: fittaj linearnu regresiju na svakom indikatoru pojedinačno
### sortaj najbolje regressore po p vrijednosti

n = 10
filtered_col_names = c()
r_squares = c()
ps = c()
col_names=colnames(x)

for(i in 1:ncol(x)){
  
  col_name=col_names[i]
  model=lm(wealth ~ x[[col_name]]) # create model with a single regressor and predict wealth
  
  summary_model = summary(model)
  
  filtered_col_names <- append(filtered_col_names, col_name)
  r_squares <- append(r_squares, summary_model$r.squared)
  # Density, distribution function, quantile function and random generation for the F distribution with df1 and df2 degrees of freedom (and optional non-centrality parameter ncp).
  # a.k.a get P value from f statistics
  f <- summary_model$fstatistic
  ps <- append(ps,  pf(f[1], f[2], f[3], lower.tail=FALSE))
}

df_g_squares=data.frame(filtered_col_names, r_squares, ps)
head(df_g_squares, n=3)
df_g_squares

# sort (by minimal r_squares) and find top n predictors
df_top_predictors = df_g_squares[order(-df_g_squares$r_squares), ]

top_n_predictors_one_var_lin = as.vector(df_top_predictors$filtered_col_names)[1:n]
df_top_predictors
```



```{r}
# pronalazak najboljih regressora s ANOVA-om
# nađi P vrijednosti za svaki regressor 
# mergaj regressore od prošlog koraka i ukolni duplikate
# dobivene regresore koristi za model

a <- anova(model_all_vars)
ps_a <- a$`Pr(>F)`
ps_a <- head(ps_a, -1) # anova returns NA for last element

ps_a_ord <- order(ps_a)
sorted_cols <- colnames(x)[order(colnames(x))]
top_predictors_anova <- sorted_cols[ps_a_ord][1:n]
cat ("Best ANOVA regressors:")
top_predictors_anova

top_predictors = c(top_predictors_anova, top_n_predictors_one_var_lin)
top_predictors <- top_predictors[!duplicated(top_predictors)]
cat ("\nTop predictors for a new model:")
top_predictors

model_top_preds <- lm(wealth ~ . , x[, top_predictors])
summary(model_top_preds)

# micanjem nekih od ovih regresora se povećava Adjusted R-squared
```




```{r, collapse=TRUE}
require(nortest)

# reziduali u ovisnosti o procjenama modela
plot(model_top_preds$fitted.values, model_top_preds$residuals) 

# provjera normalnosti reziduala
hist(rstandard(model_top_preds))
qqnorm(rstandard(model_top_preds))
ks.test(rstandard(model_top_preds),'pnorm')
lillie.test(rstandard(model_top_preds))
```



## 4. Kada biste birali karijeru isključivo prema kriteriju da se obogatite, koju biste industriju izabrali?

Pretpostavljamo da karijerom u određenoj industriji, a ne nasljedstvom zarađujemo novac. Zbog toga gledamo samo milijardere koji nisu nasljedili svoje bogatstvo.
Također, zanimaju nas samo najnoviji milijarderi odnosno oni s popisa iz 2014. godine.

 + kako prikazati trend kroz godine na grafu (dijagram paralelnih koordinata?)
 + možda gledati razliku iz popisa 2014 i 2001, odnosno nove milijardere - pa napraviti raspodjelu industrija novonastalih milijardera

```{r}
#
non_inherited_2014 <- non_inherited[non_inherited$year == 2014,]
non_inherited_2001 <- non_inherited[non_inherited$year == 2001,]
non_inherited_2014_new = bill_data[FALSE,]
non_inherited_2001_old = bill_data[FALSE,]

# selekcija novonastalih milijardera iz 2014. koji nisu bili na prethodnoj listi iz 2001.
for(i in 1:nrow(non_inherited_2014)) {
  r <- non_inherited_2014[i,]
  if(sum(str_detect(non_inherited_2001$name, r[[1]])) == 0) {
    non_inherited_2014_new <- rbind(non_inherited_2014_new, non_inherited_2014[i,])
  }
}

# selekcija milijardera iz 2001. koji nisu na listi iz 2014.
for(i in 1:nrow(non_inherited_2001)) {
  r <- non_inherited_2001[i,]
  if(sum(str_detect(non_inherited_2014$name, r[[1]])) == 0) {
    non_inherited_2001_old <- rbind(non_inherited_2001_old, non_inherited_2001[i,])
  }
}

par(mar=c(10,5,1,1))
barplot(sort(table(subset(non_inherited_2014$wealth.how.industry, non_inherited_2014$wealth.how.industry != "0")), decreasing = TRUE),
        main = "Billionaires distribution by industry in 2014 (non-inherited wealth)",
        las = 2)
barplot(sort(table(subset(non_inherited_2014_new$wealth.how.industry, non_inherited_2014_new$wealth.how.industry != "0")), decreasing = TRUE),
        main = "Newcomer billionaires distribution by industry (non-inherited wealth)",
        las = 2)
barplot(sort(table(subset(non_inherited_2001_old$wealth.how.industry, non_inherited_2001_old$wealth.how.industry != "0")), decreasing = TRUE),
        main = "Former billionaires distribution by industry (non-inherited wealth)",
        las = 2)

```

